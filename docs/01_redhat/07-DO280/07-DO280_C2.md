# Capitulo 2 - Despliegue de aplicaciones empaquetadas

Desplegar aplicaciones desde manifiestros de recursos que se empaquetan para compartir y distribuir

- Desplegar apps y sus dependencias desde manifiestos que se almacenan como templates en OCP 
- Despligue y actualización de apps desde manifiestos que se empaquetan como Helm charts

## Openshift Templates

Es un recurso personalizado de configuraciones recursos de k8s. Los templates tiene parámetros. Un recurso *template* es una extensión en Kubernetes que es proporcianado por Red Hat para OCP. Existen *templates* disponibles en el *namespace* `openshift` y durante la instalación se pueden adicionar. También se puede crear plantillas desde cero o tomar una plantilla para adaptarla para una necesidad de un proyecto.

### Descrubiendo los Templates

Listar las plantillas ejemplo del cluster de OCP del *namespace* `openshift`

``` bash
$ oc get templates -n openshift
NAME                     DESCRIPTION           PARAMETERS   OBJECTS
cache-service            Red Hat Data Grid...  8 (1 blank)  4
cakephp-mysql-example    An example CakePHP... 21 (4 blank) 8
cakephp-mysql-persistent An example CakePHP... 22 (4 blank) 9
.
.
.
```

Si se quiere revisar el contenido de un *template*

```bash

[user@host ~]$ oc describe template cache-service -n openshift
Name: cache-service
Namespace: openshift
Created: 2 months ago
Labels: samples.operator.openshift.io/managed=true
template=cache-service
Description: Red Hat Data Grid is an in-memory, distributed key/value store.
Annotations: iconClass=icon-datagrid
.
.
.

Parameters:
    Name: APPLICATION_NAME
    Display Name: Application Name
    Description: Specifies a name for the application.
    Required: true
    Value: cache-service

.
.
.

    Name: APPLICATION_PASSWORD
    Display Name: Client Password
    Description: Sets a password to authenticate client applications.
    Required: false
    Generated: expression
    From: [a-zA-Z0-9]{16}
Object Labels: template=cache-service

Message: <none>

Objects:
    Secret ${APPLICATION_NAME}
    Service ${APPLICATION_NAME}-ping
    Service ${APPLICATION_NAME}
    StatefulSet.apps ${APPLICATION_NAME}
```
Ver solamente los parametros que usa un template:

```bash
oc process --parameters cache-service -n openshift
oc process --parameters -f  my-cache-service.yaml
oc get template cache-service -o yaml -n openshift
```
### Uso de Templates

El comando `oc new-app` con el argumento `--template` puede desplegar un template directamente en el proyecto `openshift`, como el siguiente ejemplo:

```bash
oc new-app --template=cache-service -p APPLICATION_USER=my-user
```

Se puede utilizar la opción `oc process` para aplicar los parámetros de un *template* en producción.

### Crear una aplicación a partir del template:

Los siguientes ejemplos muestran cómo se puede crear aplicaciones utilizando la data de *templates*, ya que todos deben al final enviar la salida a un manifiesto final para luego aplicarlo:

```bash
## With process directly
oc process my-cache-service -p APPLICATION_USER=user1 -o yaml > my-cache-service-manifest.yaml

## With a file
oc process -f my-cache-service.yaml -p APPLICATION_USER=user1 -o yaml > my-cache-service-manifest.yaml

oc process my-cache-service -o yaml \
  -p TOTAL_CONTAINER_MEM=1024 \
  -p APPLICATION_USER='cache-user' \
  -p APPLICATION_PASSWORD='my-secret-password' \
  > my-cache-service-manifest.yaml

## With *.env to variables
cat my-cache-service-params.env
TOTAL_CONTAINER_MEM=1024
APPLICATION_USER='cache-user'
APPLICATION_PASSWORD='my-secret-password'

oc process my-cache-service -o yaml --param-file=my-cache-service-params.env > my-cache-service-manifest.yaml
```
**NOTA** Normalmente un manifiesto no se requiere  para el uso del template por lo que se puede aoplicar directamente por medio de un filtro `| oc apply -f -`

```bash
oc process my-cache-service --param-file=my-cache-service-params.env | oc apply -f -
```


```bash
oc new-app --template=cache-service -p APPLICATION_USER=my-user

oc process my-cache-service -p APPLICATION_USER=user1 -o yaml > my-cache-service-manifest.yaml

oc process -f my-cache-service.yaml -p APPLICATION_USER=user1 -o yaml > my-cache-service-manifest.yaml

oc process my-cache-service -o yaml \
-p TOTAL_CONTAINER_MEM=1024 \
-p APPLICATION_USER='cache-user' \
-p APPLICATION_PASSWORD='my-secret-password' \
> my-cache-service-manifest.yaml
```
### Update de aplicaciones desde template

Como se utiliza `oc apply`, despues de desplegar, se puede procesar el template despues para aplicar actualizaciones, pero no todos los *workloads* de updates permites esta acción, entonce se debe comparar con `oc diff -f -` agregando comop filtro para validar la diferncia entre ñps parametros aplicados:

```bash
oc process my-cache-service -o yaml --param-file=my-cache-service-params-2.env | oc diff -f -
.
.
.

- generation: 1
+ generation: 2
  labels:
    application: cache-service
    template: cache-service
      timeoutSeconds: 10
  resources:
    limits:
      - memory: 1Gi
      + memory: 2Gi
  requests:
    cpu: 500m
      - memory: 1Gi
      + memory: 2Gi
 terminationMessagePath: /dev/termination-log
 terminationMessagePolicy: File
 volumeMounts:
```

### Gestión de plantillas

Para producción, realice una copia del contenido del manifiesto del *template*, de esta forma podrá perosnalizar los valores que quiere aplicar, como:

 - Renombrar el archivo manifiesto 
 - Modificar los valores de los parámetros
 - Eliminar el *namespace*

```bash
oc get template cache-service -o yaml -n openshift > my-cache-service.yaml

oc create -f my-cache-service.yaml

oc create -f my-cache-service.yaml -n shared-templates
```

## Gráficos de Helm

**Helm** aplicación *open source* que ayuda a gestionar el lifecycle de las apps de K8S a través del concepto de gráficos, describiendo un conjunto de recursos a implementar. Algunas organizaciones distribuyen Helm Chart para desplegar apps. Importante resaltar que esto no cubre todas las necesidades de la gestión de algunas aplicaciones.

**Helm Charts** define los recursos que se pueden desplegar, es una colección de archivos definidos en una estructura los cuales contienen la metadata, definición de recursos y material de soporte. Algunos desarrolladores de este suelen utilizar lenguaje *Go* para definir recursos

* Estructura básica de archivos Helm
``` bash
ejemplo_chart/
├── Chart.yaml
├── templates
| |── example.yaml
└── values.yaml
```

## Usando Helm Charts

Como tal es una app CLI con comandos interactivos con las siguientes identidades

|Identidad | Descripción |
|:-------- |:----------- |
|Charts | Apps empaquetadas que despliegan con ```helm ``` |
|Releases | La implementación de un Chart. Cada implemenatción es un *Release* diferente y puede hacerlo n veces en el mismo clúster |
|Versions | Un chart puede tener muchas *versiones* |